    2.4 多态
        1：概念：继承或接口实现是多态性前提。一个对象拥有多种形态，这就是对象的多态性。
                代码当中体现多态性其实就是【父类引用指向子类对象】。
        2：格式：
            父类名称 对象名 = new 子类名称();
            或者
            接口名称 对象名 = new 实现类名称();
        3：多态种成员变量的使用特点：
            直接通过对象名称访问成员变量：看等号左边是谁，优先用谁，没有则向上找；
            间接通过成员方法访问成员变量；方法属于谁，就优先用谁的成员变量，没有则向父类找。
            口诀：编译看左边，运行【还】看左边
        4：多态中成员方法的访问特点：
            看new的是谁，就优先用谁，没有则向上找
            口诀：编译看左边，运行看右边。
        5：对象的向上转型：
            就是多态写法：
                格式：父类名称 对象名 = new 子类名称();
                含义：右侧创建一个子类对象，把它当做父类来看待使用。
            注意事项：
                向上转型一定是安全的。
                但也有一个弊端：一旦向上转型为父类就无法调用子类原本的特有方法。（此时应再向下转型）
        6：对象的向下转型：
            多态的还原：
                格式：子类对象 对象名 = (子类名称) 父类对象;
                含义：将父类对象【还原】成为本来的子类对象。
            注意事项：
                必须保证对象本来创建的时候，就是子类，才能向下转型为子类；
                如果对象创建的时候本来不是子类，现在非要向下转型成为子类，就会报错。
        7：用instanceof关键字：
            如何知道一个父类对象引用的对象，本来是什么子类？
            格式：
                对象名 instanceof 类型
                这将得到一个boolean值结果，也就是判断前面的对象能不能当做后面类型的实例。
    2.5 final类
        1：概念：代表最终不可改变的
        2：常见四种用法：
            可以用来修饰一个类：
                格式：
                    public final class 类名称{
                        //...
                    }
                含义：
                    当前这个类不能有任何的子类。（太监类）
                注意：
                    一个类如果是final类，那么其中的所有成员方法都无法进行覆盖重写

            可以用来修饰一个方法：
                这个方法就是最终方法，也就是不能被覆盖重写
            可以用来修饰一个局部变量：
                一旦使用final用来修饰局部变量，那么这个变量就不能进行更改,只能赋值一次。
                    对于基本类型来说，不可变说的是变量当中的【数据】不可改变
                    对于引用类型来说，不可变说的是变量当中的【地址值】不可改变
            可以用来修饰一个成员变量：
                由于成员变量具有默认值，所以用了final之后必须手动赋值，不会再给默认值了。
                对于final的成员变量，要么直接复制，要么通过构造方法赋值。二者选其一。
                必须保证类当中所有重载的构造方法，都最终会对final的成员变量进行赋值。
            注意事项：
                对于类、方法来说，abstract关键字和final关键字不能同时使用，因为矛盾。
    2.6 四种权限修饰符
        1：四种权限修饰符public > protected > (default) > private
        2：四种情况：
                                      public    protected    (default)    private
            同一个类（我自己）：         Yes         Yes          Yes         Yes
            同一个包（我邻居）：         Yes         Yes          Yes         No
            不同包的子类（我儿子）：     Yes         Yes          No          No
            不同包的非子类（陌生人）：    Yes         No           No          No
    2.7 内部类
        1：概念：一个类内部包含另一个类。
        2：分类：
            成员内部类；
            局部内部类（包含匿名内部类）；
        3：成员内部类：
            定义格式：
                修饰符 class 类名称 {
                    修饰符 class 类名称 {
                        //...
                    }
                    //...
                }
            注意：【内用外】可以随意访问，【外用内】需要借助内部类对象。
            使用方法：
                间接方式：在外部类的方法当中，使用内部类；然后main只调用外部类的方法。
                直接方式：
                    公式：外.内
                         外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称();
        4：局部内部类：
            定义格式：
                修饰符 class 外部类名称 {
                    修饰符 返回值类型 外部类方法名称(参数列表){
                        class 局部内部类名称 {
                            //...
                        }
                    }
                }
            使用方法：
                在外部类中创建局部内部类对象，通过局部内部类对象调用局部内部类方法。
            注意事项：
                局部内部类的final问题：
                    局部内部类如果希望访问所在方法的局部变量，那么这个局部变量必须是【有效final的】；
                    从Java8开始，只要局部变量事实不变，那么final关键字可以省略。
                        原因：
                            new出来的对象在堆内存当中；
                            局部变量是跟着方法走的，在栈内存当中；
                            方法运行结束之后立刻出栈，局部变量就会立刻消失；
                            new出来的对象会在堆当中持续存在，直到垃圾回收消失。
        5：总结一下权限修饰符：
            外部类：public/(default)
            成员内部类：public/protected/(default)/private
            局部内部类：什么都不能写
        6：匿名内部类：
            定义格式：
                接口名称 对象名 = new 接口名称(){
                    //覆盖重写接口中所有抽象方法
                };
            注意事项：
                对格式“new 接口名称() {...};”进行解析：
                    new代表创建对象的动作；
                    接口名称就是匿名内部类需要实现哪个接口；
                    {...}这是匿名内部类的内容。
                匿名内部类在创建对象的时候只能使用唯一一次；
                如果希望多次创建对象，而且类的内容一样的话，那么就必须使用单独定义的实现类了;
                匿名对象，在【调用方法】的时候，只能调用唯一一次，
                如果希望同一个对象，调用多次方法，那么必须给对象起个名字；
                匿名内部类是省略了【实现类（或者子类）的名称】，但是匿名对象是省略了【对象名称】；
                匿名内部类和匿名对象不是一回事。