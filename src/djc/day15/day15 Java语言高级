    4.3 数据结构
        1：栈：
            Stack，又称堆栈，是运算受限的线性表；
            其限制是仅允许在标的一端进行插入和删除操作，不允许在其他任何位置进行添加、朝招、删除等操作。
            先进后出（存进去的元素，要在后它后面的元素依次取出后，才能取出该元素）；
            入栈（压栈）：存储集合元素到集合
            出栈（弹栈）：取出集合中元素
            栈的入口、出口都在栈的顶端位置。
        2：队列：
            queue，简称队，是一种运算受限的线性表；
            其限制是仅允许在表的一端进行插入，而在表的另一端进行删除。
            先进先出（存进去的元素，要在它前面的元素依次取出后，才能取出该元素）；
            队列的入口、出口各占一侧。
        3：数组：
            Array，是有序的元素序列，数组是在内存中开辟一段连续的空间，并在此空间存放元素。
            查询快，增删慢。
            查找元素快：
                通过索引，可以快速访问指定位置的元素
            增删元素慢：
                数组长度固定，想要增加或删除一个元素必须创建一个新数组，
                然后把源数组数据复制过来，源数组会在内存中被销毁（垃圾回收）。
        4：链表（单向链表）：
            linked list，由一系列结点node（链表中每一个元素称为结点）组成；
            结点可以在运行时动态生成。
            每个结点包括两部分：
                一个存储数据元素的数据域（存储数据）；
                两个存储结点地址的指针域（存储地址）。
            多个结点之间，通过地址进行连接；
            查找元素慢：
                链表中的地址不是连续的，每次查询元素都必须从头开始查询
            增删元素快：
                链表结构增加或删除一个元素，对链表的整体结构没有影响
            单向链表：链表中只有一条链子，不能保证元素的顺序（存储元素和取出元素的顺序有可能不一致）
            双向链表：链表中有两条链子，有一条链子是专门记录元素的顺序的，是一个有序的集合
        5：红黑树：
            二叉树:binary tree，，是每个结点不超过2的有序树。
            二叉树是每个结点最多有两个子树的树结构，顶上的叫根结点，两边被称作“左子树”和“右子树”。
            排序树/查找树：
                在二叉树的基础上，元素是有大小排序的，左子树小，右子树大。
            平衡树：
                左孩子等于右孩子
            不平衡数：
                左孩子不等于右孩子
            红黑树：
                特点：
                    趋近于平衡树，查询的速度非常快，查询叶子结点最大次数和最小次数不能超过2倍。
                约束条件：
                    结点可以是红色或者黑色的；
                    根结点是黑色的；
                    叶子结点（空结点）是黑色的；
                    每个红色的结点的子结点都是黑色的；
                    任何一个结点到其每一个叶子结点的所有路径上黑色结点的数量是相同的
    4.4 List集合
        1：概念：
            java.util.List接口继承自Collection接口。
        2：特点：
            有序的集合，存储元素和取出元素的顺序是一致的；
            有索引，包含了一些带索引的方法；
            允许存储重复元素。
        3：带索引的方法：
            public void add(int index, E element)：
                将指定的元素，添加到该集合中的指定位置上
            public E get(int index)：
                返回集合中指定位置的元素
            public E remove(int index)：
                移除列表中指定位置的元素，返回的是被移除的元素
            public E set(int index, E element)：
                用指定元素替换集合中指定位置的元素，返回值是被替换的元素
            注意：
                操作索引的时候，一定要防止索引越界异常。
        4：ArrayList集合：
            java.util.ArrayList集合数据层存储的结构是数组结构。
            元素增删慢，查询快。
        5：LinkedList集合：
            java.util.LinkedList集合数据存储的结构是链表结构。
            方便元素的添加、删除。
            LinkedList是一个双向链表。
            实际开发中对一个集合元素的添加与删除经常涉及到首尾操作；
            LinkedList提供了大量首尾操作的方法：
                public void addFirst(E e)：
                    将指定元素插入此列表开头。
                等效于：
                public void push(E e)：
                    将元素推入此列表所表示的堆栈。换句话说，将该元素插入此列表的开头。
                public void addLast()：
                    将指定元素添加到此列表的结尾。
                public E getFirst()：
                    返回此列表的第一个元素。
                public E getLast()：
                    返回此列表的最后一个元素。
                public E removeFirst()：
                    移除并返回此列表的第一个元素。
                等效于：
                public E pop()：
                    从此列表所表示的堆栈处弹出一个元素。换句话说，移除并返回此列表的第一个元素。
                public E removeLast()：
                    移除并返回此列表的最后一个元素。
            注意：
                使用LinkedList集合特有的方法，不能使用多态。
        6：Vector集合：
            是一个单列集合。Vector 类可以实现可增长的对象数组。
            与数组一样，它包含可以使用整数索引进行访问的组件。
            Vector的大小可以根据需要增大或缩小，以适应创建Vector后进行添加或移除项的操作。
    4.5 Set集合
        1：Set接口:
            java.util.Set继承自Collection接口。
        2：特点：
            没有带索引的方法，不能使用普通的for循环遍历；
            不允许存储重复元素。
        3：实现类：
            java.util.HashSet:
                无序的集合,存储元素和取出元素顺序有可能不一致；
                没有带索引的方法，不能使用普通的for循环遍历；
                不允许存储重复元素；
                底层是一个哈希表结构（查询速度非常快）。
        4：哈希表：
            哈希值：
                是一个十进制的整数，由系统随机给出；
                是对象的地址值，是一个逻辑地址，模拟出来的地址，不是数据实际存储的物理地址；
                Object类有一个方法，可以获取对象的哈希值：
                    int hashCode()返回该对象的哈希码值
                    public native int hashCode();
                    native：代表该方法调用的是本地操作系统的方法
            哈希表：
                jdk1.8版本之前：
                    哈希表 = 数组 + 链表
                jdk1.8版本之后：
                    哈希表 = 数组 + 链表
                    哈希表 = 数组 + 红黑树（链表长度超过8）
                数组结构：
                    把元素进行了分组（相同哈希值是一组）；
                    链表/红黑树结构把相同哈希值的元素连接到一起
        5：LinkedHashSet集合：
            特点：
                底层是一个哈希表（数组+链表/红黑树）+链表：
                    多了一条链表用来记录元素的存储顺序，保证元素有序
        6：可变参数：
            在JDK1.5之后，如果我们定义一个方法需要接受多个参数，并且多个参数类型一致，
            我们可以对其简化成如下格式：
                修饰符 返回值类型 方法名(参数类型...形参名){ }
            等价于
                修饰符 返回值类型 方法名(参数类型[] 形参名){ }
            后面的这种定义在调用时必须传递数组；
            前者可以直接传递数据即可。
            使用前提：
                当方法的参数列表数据类型已经确定，但是参数的个数不确定，就可以使用可变参数。
            原理：
                可变参数的底层就是一个数组，根据传递参数个数不同，会创建不同长度的数组，来存储这些参数
                传递的参数个数，可以是0个，1个...多个
            注意事项：
                一个方法的参数列表，只能有一个可变参数；
                如果方法的参数有多个，那么可变参数必须写在参数列表的末尾
    4.6 Collections工具类
        1：常用方法：
            public static <T> boolean addAll(Collection<? super T> c,T... elements)：
                将所有指定元素添加到指定 collection 中。可以分别指定要添加的元素，或者将它们指定为一个数组。
            public static void shuffle(List<?> list)：
                使用默认随机源对指定列表进行置换。
            public static <T> void sort(List<T> list):
                根据元素的自然顺序，对指定列表按升序进行排序；
                列表中的所有元素都必须实现 Comparable 接口；
                列表中的所有元素都必须是可相互比较的。
            public static <T> void sort(List<T> list,Comparator<? super T> c)：
                根据指定比较器产生的顺序对指定列表进行排序；
                此列表内的所有元素都必须可使用指定比较器相互比较。
            注意事项：
                sort(List<T> list)使用前提：
                    被排序的集合里边存储的元素，必须实现Comparable接口；
                    重写接口中的方法compareTo定义排序的规则
                        compareTo排序规则：
                            return 自己（this）- 参数：升序
                            return 参数 - 自己（this）：降序