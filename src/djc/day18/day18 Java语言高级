    5.2 线程实现方式
        1：并发于并行：
            并发：指两个或多个事件在同一个时间段内发生 ——交替执行
            并行：指两个或多个事件在同一时刻发生（同时发生）——同时执行
        2：进程与线程：
            进程：
                进程是指一个内存中运行的应用程序；
                每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；
                进程也是程序的一次执行过程，是系统运行程序的基本单位；
                系统运行一个程序既是一个进程从创建、运行到消亡的过程。
            线程：
                线程是进程的一个执行单位，负责当前进程中程序的进行；
                一个进程中至少有一个线程，一个进程中是可以有多个线程的（多线程程序）；
            线程的调度：
                分时调度：
                    所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间。
                抢占式调度：
                    优先让优先级高的线程使用CPU；
                    如果线程的优先级相同，那么会随机选择一个（线程随机性）。
                    Java使用的就是抢占式调度。
        3：主线程：
            执行主方法的线程。
            Java是单线程，执行从main方法开始从上到下依次执行。
        4：创建线程类：
            创建多线程类的第一种方式：
                创建Thread类的子类：
                    java.lang.Thread：
                        是描述线程的类，我们想要实现多线程，就必须继承Thread类
                实现步骤：
                    创建一个Thread类的子类；
                    在Thread类的子类中重写Thread类中的run方法，设置线程任务（开启线程的目的）；
                    创建Thread类的子类对象；
                    调用Thread类中的方法start方法开启新的线程，执行run方法：
                        public void start()：
                            使该线程开始执行；Java虚拟机调用该线程的run方法；
                            结果是两个线程并发地运行，当前线程（main线程）和另一个线程（创建的新线程，执行其run方法）；
                            多次启动一个线程是非法的，特别是当线程已经结束执行后，不能再重新启动；
            创建多线程类的第二种方式：
                实现Runnable接口：
                    java.lang.RunnableRunnable：
                        接口应该由那些打算通过某一线程执行其实例的类来实现；
                        类必须定义一个称为 run 的无参数方法。
                    java.lang.Thread类的构造方法：
                        Thread(Runnable target)
                            分配新的 Thread 对象。
                        Thread(Runnable target, String name)
                            分配新的 Thread 对象。
                实现步骤：
                    创建一个Runnable接口的实现类；
                    在实现类中重写Runnable接口的run方法，设置线程任务；
                    创建一个Runnable接口的实现类对象；
                    创建Thread类对象，构造方法中传递Runnable的实现类对象
                    调用Thread类中的start方法，开启新的线程，执行run方法
        5：Thread和Runnable的区别：
            如果一个类继承Thread，则不适合资源共享；
            但是如果实现了Runnable接口的话，则很容易实现资源共享。
            实现Runnable接口比继承Thread类所具有的优势：
                适合多个相同的程序代码的线程去共享一个资源；
                可以避免java中的单继承的局限性：
                    一个类只能继承一个类，如果一个类继承了Thread类就不能再继承其他的类了
                    实现了Runnable接口，还可以继承其他的类，实现其他的接口
                增加程序的扩展性，实现解耦操作（降低耦合性），代码可以被多个线程共享，代码和线程独立：
                    实现Runnable接口的方式，把设置线程任务和开启新线程进行了分离（解耦）
                    实现类中重写了run方法，来设置线程任务
                    创建Thread类对象，调用start，用来开启新的线程
                线程池只能放入实现Runnable和Callable类线程，不能直接放入继承Thread的类。
        6：Thread类的常用方法：
            public final String getName()：
                返回该线程的名称。
            public static void sleep(long millis)：
                在指定的毫秒数内让当前正在执行的线程休眠（暂停执行）。
        7：匿名内部类方式实现线程的创建：
            匿名内部类作用：
                把子类继承父类，重写父类方法，创建子类对象，合成一步完成；
                把实现类实现接口，重写接口中的方法，创建实现类对象，合成一步完成。
            匿名内部类最终产物：
                子类/实现类对象，而这个类没有名字
            格式：
                new 父类/接口(){
                    重写父类/接口中的方法
                };
    5.3 线程同步机制
        1：线程安全问题的概述：
            单线程程序是不会出现线程安全问题的；
            多线程程序，没有访问共享数据，不会产生安全问题；
            多线程程序，访问了共享数据，会产生安全问题。
        2：解决线程安全问题_同步代码块：
            同步代码块：
                synchronized关键字可以用于方法中的某个区块中；
                表示只对这个区块的资源实行互斥访问。
            格式：
                synchronized(锁对象){
                    需要同步操作的代码
                }
            注意：
               通过代码块中的锁对象，可以使用任意的对象；
               但是必须保证多个线程使用的锁对象是同一个；
               锁对象作用：
                  把同步代码块锁住，只让一个线程在同步代码块中执行。
        3：解决线程安全问题_同步方法：
            同步方法：
                使用synchronized修饰的方法，就叫同步方法；
                保证A线程执行该方法的时候，其他线程只能在方法外等待。
            格式：
                public synchronized void method(){
                    可能会产生线程安全问题的代码
                }
            使用步骤：
                把访问了共享数据的代码抽取出来，放到一个方法中；
                在方法上添加一个synchronized修饰符
        4：Lock锁：
            java.util.concurrent.locks.Lock接口：
                Lock 实现提供了比使用 synchronized 方法和语句可获得的更广泛的锁定操作。
            Lock接口中的方法：
                void lock()：获取锁。
                void unlock()：释放锁。
            java.util.concurrent.locks.ReentrantLock implements Lock
            使用步骤：
                在成员位置创建一个Lock的实现类对象ReentrantLock；
                在可能会出现线程安全问题的代码前调用Lock接口中的方法lock获取锁；
                在可能会出现线程安全问题的代码后调用Lock接口中的方法unlock释放锁；